# Элементы

[TOC]

Элемент фабрики в Битрикс24 — это базовая единица данных, используемая для управления и автоматизации бизнес-процессов. Элементы фабрики могут представлять собой различные сущности, такие как сделки, лиды, контакты, компании и другие объекты CRM. Каждый элемент содержит набор полей и свойств, которые описывают его характеристики и состояние.

Каждый элемент описывается наследником абстраткого класса `Bitrix\Crm\Item`, например сделка описывается классом `Bitrix\Crm\Item\Deal` наследником `Bitrix\Crm\Item`.


## Получение элементов

На [фабрике](/04_Модуль_CRM/10_Универсальное_api/20_Фабрики.md) существует 4 способа для получения элементов:
- Получение объекта по идентификатору
- Получение объектов по фильтру
- Получение объектов по фильтру с учетом прав
- Низкоуровневые запросы


**Я знаю ID элемента, как мне получить объект?**

Для получения объекта по идентификатору существует метод `getItem(int $id): ?Item`.
Пример использования:

```php

$elementId = 123;

/**
 * @var \Bitrix\Crm\Item
 */
$itemObject = $factory->getItem($elementId);
```

**Я хочу найти все элементы по фильтру**

Предположим мы хотим найти все элементы по какому-то фильтру (например ID больше 10 и меньше 15).
Получить элементы можно используя метод `getItems(array $parameters = []): array`:

```php
$filter = [
    '><ID' => [10, 15],
];

$elements = $factory->getItems([
    'filter' => $filter
]);
```

Предположим, мы хотим усовершенствовать запрос и получить только те элементы которые доступны текущему пользователю - для этого можно воспользоваться методом `getItemsFilteredByPermissions`, который имеет следующую сигнатуру:

```php
public function getItemsFilteredByPermissions(
    array $parameters,
    ?int $userId = null,
    string $operation = UserPermissions::OPERATION_READ
): array
```

Используя этот метод мы можем получить не только элементы доступные текущему пользователю, но так же можем запросить еще и доступные другомому пользователю с учетом его прав на элементы.

Набор параметров `$parameters` являетися унифицированным и наиболее приближен к [параметрам ORM](https://dev.1c-bitrix.ru/learning/course/index.php?COURSE_ID=43&LESSON_ID=5753&LESSON_PATH=3913.3516.5748.5063.5753), однако настоятельно не рекомендую использовать в методах поиска что-либо кроме `filter`, `order`, `limit`, `offset`, а `runtime` использовать с осторожностью.

В фильтре допустимо использовать следующие примеры:
```
= равно (работает и с массивами)
% подстрока
> больше
< меньше
@  IN (EXPR), в качестве значения передается массив или объект DB\SqlExpression
!@  NOT IN (EXPR), в качестве значения передается массив или объект DB\SqlExpression

!= не равно
!% не подстрока
>< между, в качестве значения передается массив array(MIN, MAX)
>= больше или равно
<= меньше или равно
=% LIKE
%= LIKE

Пояснение по префиксам
Префиксы %= и =% эквивалентны, все примеры для одного подходят для второго:
'%=NAME' => 'тест' - отбор строки по LIKE (НЕ ПОДСТРОКИ)
'%=NAME' => 'тест%' - отбор записей, содержащих "тест" в начале поля NAME
'%=NAME' => '%тест' - отбор записей, содержащих "тест" в конце поля NAME
'%=NAME' => '%тест%' - отбор записей, содержащих подстроку "тест" в поле NAME
Последний вариант отличается от %NAME => тест итоговым sql-запросом.
== булевое выражение для ExpressionField (например, для EXISTS() или NOT EXISTS())
!>< не между, в качестве значения передается массив array(MIN, MAX)
!=% NOT LIKE
!%= NOT LIKE
'==ID' => null - условие, что поле ID равно NULL (в sql-запросе будет преобразовано в ID IS NULL)
'!==NAME' => null - условие, что поле NAME не равно NULL (в sql-запросе будет преобразовано в NAME IS NOT NULL)
```

## Подсчет количества

Часто возникает необходимо получить только количество элементов удовлетворяющих фильтру и в таком случае запрашивать все поля элементов представляется сильно избыточным механизмом.
Для этого у фабрики есть методы `getItemsCount` и `getItemsCountFilteredByPermissions` которые находят количество элементов по фильтру и то же самое только с учетом прав.
Сигнатуры методов выглядят следующим образом:

```php
public function getItemsCount(array $filter = []): int

public function getItemsCountFilteredByPermissions(
        array $filter = [],
        ?int $userId = null,
        string $operation = UserPermissions::OPERATION_READ
    ): int
```

Пример подсчета элементов, которые начинаются в буквы "А":
```php
$filter = [
    '%=NAME' => 'A'
];

$elementCount = $factory->getItemsCount([
    'filter' => $filter
]);
```

## Создание элемента

Мы разобрали ситуацию когда элементы уже существуют, но как правильно создать элементы? Поскольку фабрика является абстрактной (незивестно какие поля она имеет) элемент так же является абстракцией. Чтобы получить объект необходимо использовать метод `createItem(array $data = []): Item`, при этом в ключе `$data` можно указать первоначальные значения.

Пример создание объекта(!) сделки с заранее установленным названием:
```php
$newDeal = $factory->createItem([
    'TITLE' => 'New Title'
]);
```

Не обязательно знать все поля сразу, можно воспользоваться сеттерами позднее:

```php
/**
 * Create deal object
 *
 * @var       \Bitrix\Crm\Item\Deal
 */
$newDeal = $factory->createItem();

// Configure title with margic method

$newDeal->setTitle("NewTitle");

// or configure with "general" method

$newDeal->set('TITLE', 'NewTitle');
```

>Важное примечание: создание объекта сделки это не создание самой сделки. Объект еще необходимо сохранить в базе данных, поэтому если вы не сделали сохранение по завершению скрипта объект будет уничтожен и данные потеряны!

Сохранение самого элемента в базе данных выполняется при помощи [операций](/04_Модуль_CRM/10_Универсальное_api/40_Операции.md).

## Редактирование элемента

Процесс редактирования элемента аналогичен процессу работы с созданием элемента, с отличием в том что вы используете операцию редактирования и элемент у вас уже существует.
Сейчас мы не будем вдаваться в подробности выполнения [операции обновления](/04_Модуль_CRM/10_Универсальное_api/40_Операции.md), а покажем пример изменения названия у существующего элемента.
Предположим нам необходимо поменять название (на `Updated title`) и ответственного (на пользователя с ID = `3`) у элемента ID:10 смарт-процесса с типом 163:

```php
use \Bitrix\Main\Loader;
use \Bitrix\Crm\Service\Container;

Loader::requireModule('crm');

$dealFactory = Container::getInstance()->getFactory( 163 );

$elementId = 10;

$itemObject = $factory->getItem($elementId);

$itemObject->setTitle("Updated title")
    ->setAssignedById(3);
```

>Важное примечание: выполнение методов на изменение полей в объекте меняет данные самого объекта и не будут сохранены в базу данных до выполнения соответствующей операции.

В приведенном примере мы воспользовались приемом "цепочки вызовов" - почти каждый set* метод возвращает свой экземпляр, поэтому вместо того чтобы копировать одинаковые строчки мы можем использовать более простую конструкцию. Например мы могли бы написать этот код иначе и результат работы от этого не изменился бы:

```php
$itemObject->setTitle("Updated title");
$itemObject->setAssignedById(3);
```

Подробнее с существующими методами можно ознакомиться в классе `bitrix/modules/crm/lib/item.php`.


## Работа с элементом

Ранее мы изучили работу над элементами и теперь когда мы знаем как создать или получить элемент пришло время поговорить о самом элементе. 
Представление элемента в коде в универсальном api - объект и это представление конкретного элемента.
Можно по разному классифицировать его "свойства":
- Делить на общие (присующие всем элементам, например название) и частные (существующие только у определенного, например UF-* поля)
- Рассматривать с точки зрения хранения - скалярные (число, строка) и связи (товарные позиции, наблюдатели)

Материал не в состоянии охватить все аспекты работы с элементом, поэтому в данной главе мы будем рассматривать лишь некоторые случаи для демонстрации общего подхода.

### Массив

Иногда необходимо получить вметсо объектного представления - массив или json. За это отвечают специальные методы:

```php

$elementArray = $element->getCompatibleData();
echo "<pre>";
var_dump($elementArray);
echo "</pre>";


$jsonString = $element->jsonSerialize();  
$jsonString = $element->toArray(); // Alias for jsonSerialize method  

```

>Не пытайтесь посмотреть элемент через `var_dump` или `print_r` - это чревато большим расходом памяти - ваш битрикс может не выдержать и упасть из-за недостатка памяти. Вы получите белую страницу.

Важно обратить внимание - `getCompatibleData` умеет принимать параметр отвечающий за то какого именно типа данные должны быть извлечены. Допустимы следующие параметры:
- `\Bitrix\Main\ORM\Objectify\Values::ALL` - вернутся все значения полей (по-умолчанию)
- `\Bitrix\Main\ORM\Objectify\Values::ACTUAL` - вернутся только исходные значения полей
- `\Bitrix\Main\ORM\Objectify\Values::CURRENT` - вернутся только текущие значения полей 


### Общие и uf поля

Получить значение поля можно двумя способами: через магический метод и через общий метод.

Пример получения данных через магический метод:

```php
$title = $element->getTitle();
```

Пример получения данных через общий метод:
```php
$title = $element->get('TITLE');
```

Аналогично методам `get` существуют `set` методы:
```php
$element->setTitle("Your title here");
```

И общий метод:
```php
$element->set('TITLE', "Your title here");
```

Какие еще данные можно получать? 
Список достаточно большой, например включая но не ограничиваясь: 
```php
/**
 * Class Item
 * @package Bitrix\Crm
 *
 * @method string|null getTitle()
 * @method Item setTitle(string $title)
 * @method bool isChangedTitle()
 * @method DateTime|null getCreatedTime()
 * @method Item setCreatedTime(DateTime $dateTime)
 * @method DateTime|null getUpdatedTime()
 * @method Item setUpdatedTime(DateTime $dateTime)
 * @method DateTime|null getMovedTime()
 * @method Item setMovedTime(DateTime $dateTime)
 * @method int|null getCreatedBy()
 * @method Item setCreatedBy(int $createdBy)
 * @method int|null getUpdatedBy()
 * @method Item setUpdatedBy(int $updatedBy)
 * @method int|null getMovedBy()
 * @method Item setMovedBy(int $movedBy)
 * @method int|null getAssignedById()
 * @method Item setAssignedById(int $assignedById)
 * @method bool|null getOpened()
 * @method Item setOpened(bool $isOpened)
 * @method Date|null getBegindate()
 * @method Item setBegindate(Date $begindate)
 * ...
 * ...
 * ...
 */
```

>Подробнее с существующими методами можно ознакомиться в классе `bitrix/modules/crm/lib/item.php`.

Важное примечание: поскольку элемент это абстракция некоторые поля могут иметь одинаковое семантическое значение, но разный код. Например поле "Статус лида" и "Стадия сделки" - они оба хранят статус элемента но имеют разные коды. Для таких полей в классе `\Bitrix\Crm\Item` и его наследниках есть константы полей позволяющие унифицировать работу с элементом - `FIELD_NAME_*` константы.

Например для получения стадии лида И сделки можно использовать следующий универсальный код:

```php
$element->get( $element::FIELD_NAME_STAGE_ID ); 
``` 

Работа с пользовательскими полями не отличается от общих полей, разве что именем служит код такого поля.
Например для изменения поля `UF_CRM_9_UDTGLCGT` будет одинаково работать как код:

```php
$element->set('UF_CRM_9_UDTGLCGT', $value);
```

так и:

```php
$element->setUfCrm9Udtglcgt($value);
```

Однако во избежание ошибок трансформации названия **вариант с camelCase строго не рекомендуется**.
>Что вообще за ошибка трансформации? Битрикс пытается привести к camelCase к snakeCase варианту через замену подчеркивание на uppercase символ, таким образом `ASSIGNED_BY_ID` становится `assignedById`, но у цифр uppercase варианта нет, а в системе технически могут существовать 2 разных поля `UF_CRM_1_1` и `UF_CRM_11`. Представьте себя на месте Битрикса - куда положить значение поля `ufCrm11` ? 


### Товарные позиции


```php

$productParseResult = $invoice->setProductRowsFromArrays([
    [
        'PRODUCT_NAME' => 'Пестик',
        'PRODUCT_ID' => '222',
        'PRICE' => 100,
        'QUANTITY' => 1,
    ],
    [
        'PRODUCT_NAME' => 'Тычинка',
        'PRODUCT_ID' => '333',
        'PRICE' => 150,
        'QUANTITY' => 2,
    ],
]);

if ( !$productParseResult->isSuccess() )
{
    // Something wrong with products - no add invoice
    return null;
}


    //region Products
    /**
     * Bind a new product to this item
     *
     * @param ProductRow $product
     *
     * @return Result
     */
    public function addToProductRows(ProductRow $product): Result
    {
        $normalizationResult = $this->normalizeProduct($product);

        if ($normalizationResult->isSuccess())
        {
            $this->addToProductsCollection($product);
        }

        return $normalizationResult;
    }

    /**
     * Update fields of a product that is already bound to this item.
     * If the provided product is new and not bound, error will be returned.
     *
     * @param int $productRowId - id of a ProductRow that is being updated
     * @param array $productRowArray - array of field values that need to change. If some value for some field is not
     * provided, it's considered not changed and previous value remains
     *
     * @return Result
     */
    public function updateProductRow(int $productRowId, array $productRowArray): Result
    {
        $originalProduct = $this->getProductRows() ? $this->getProductRows()->getByPrimary($productRowId) : null;
        if (!$originalProduct)
        {
            return (new Result())
                ->addError(new Error('The provided product is not bound to the item'))
                ;
        }

        foreach ($productRowArray as $fieldName => $value)
        {
            if ($originalProduct->entity->hasField($fieldName))
            {
                $originalProduct->set($fieldName, $value);
            }
        }

        $normalizationResult = $this->normalizeProduct($originalProduct);
        if (!$normalizationResult->isSuccess())
        {
            $originalProduct->resetAll();
        }

        return $normalizationResult;
    }

    /**
     * Unbind an existing product from this item
     *
     * @param ProductRow $product
     */
    public function removeFromProductRows(ProductRow $product): void
    {
        $entityFieldName = $this->getEntityFieldNameByMap(static::FIELD_NAME_PRODUCTS);
        $this->entityObject->removeFrom($entityFieldName, $product);
    }

    /**
     * Alias for @see Item::setProductRows()
     *
     * @param array[] $productArrays - array of product arrays
     *
     * @return Result
     */
    public function setProductRowsFromArrays(array $productArrays): Result
    {
        $products = [];
        foreach ($productArrays as $productArray)
        {
            $products[] = ProductRow::createFromArray($productArray);
        }

        return $this->setProductRows($products);
    }

    /**
     * Set products for this item
     * Adds new products, updates existing ones
     * If some products were not sent to this method - they are deleted
     *
     * @param ProductRow[]|EO_ProductRow_Collection $products
     *
     * @return Result
     */
    public function setProductRows($products): Result
    {
        $results = [];
        foreach ($products as $product)
        {
            $normalizationResult = $this->normalizeProduct($product);
            $results[] = $normalizationResult;
            if (
                $normalizationResult->isSuccess()
                && !$this->isSameProductInCollection($this->getProductRows() ?? [], $product)
            )
            {
                $this->saveProduct($product);
            }
        }

        $this->deleteNotProvidedProducts($products);

        return $this->mergeResults($results);
    }
```


### Файлы


```php
\Bitrix\Main\Loader::includeModule('crm');

$fileId = \Bitrix\Main\FileTable::getList(['select' => ['ID'],'limit' => 1])->fetch()['ID'];

$singleFileFieldName = 'UF_CRM_24_1617111871459';
$multipleFileFieldName = 'UF_CRM_24_1617111881791';

$factory = \Bitrix\Crm\Service\Container::getInstance()->getFactory(132);

$fieldsCollection = $factory->getFieldsCollection();

$singleFileField = $fieldsCollection->getField($singleFileFieldName);
$multipleFileField = $fieldsCollection->getField($multipleFileFieldName);

$item = $factory->createItem();
$item->set($singleFileFieldName, $fileId);
$item->set($multipleFileFieldName, [$fileId]);

$fileUploader = \Bitrix\Crm\Service\Container::getInstance()->getFileUploader();
$fileUploader->registerFileId($singleFileField, $fileId);
$fileUploader->registerFileId($multipleFileField, $fileId);

$result = $factory->getAddOperation($item)->launch();

if (!$result->isSuccess())
{
  print_r($result->getErrorMessages());
}

var_dump($item->get($singleFileFieldName));
var_dump($item->get($multipleFileFieldName));

```

### Связи



## Полезные ссылки

[Элементы в документации](https://dev.1c-bitrix.ru/api_d7/bitrix/crm/item/index.php)
[Особенности работы с коллекциями в документации](https://dev.1c-bitrix.ru/api_d7/bitrix/crm/item/work_with_collections_details.php)